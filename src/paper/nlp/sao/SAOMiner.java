package paper.nlp.sao;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import paper.nlp.NLPTool;
import paper.nlp.Rules;
import paper.nlp.phrase.PhraseGroup;
import paper.nlp.phrase.PhraseMiner;
import paper.nlp.phrase.object.NounPhrase;
import paper.nlp.phrase.object.SubjPhrase;
import paper.nlp.phrase.object.Verb;
import paper.nlp.phrase.object.VerbPhrase;

import edu.stanford.nlp.ling.CoreLabel;
import edu.stanford.nlp.ling.HasWord;
import edu.stanford.nlp.ling.LabeledWord;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.trees.TreeGraphNode;
import edu.stanford.nlp.trees.TreePrint;
import edu.stanford.nlp.trees.TypedDependency;

public class SAOMiner {
	
	public static void main(String[] args) {
		String p5446286 = "An efficient and ultrafast sensor for X-ray and UV radiation based on doped nanocrystals. These doped nanocrystals consist preferably of impurity-activator doped wide band gap II-VI semiconductors. They yield high efficiency and short recombination time radiation-sensitive phosphors which in response to radiation emit visible light easily detected by conventional sensors such as Si sensors. The combination of pulsed UV/X-ray sources with efficient and ultrafast sensors will yield sensors with increased signal to noise ratio. In a preferred embodiment, thin films of doped nanocrystals are used for generating visible radiation, which can be imaged with a conventional Si-based camera. Other applications also include the use of doped nanocrystals of piezoelectric materials to sense pressure, of pyroelectric materials to sense heat, and of ferroelectric materials to sense electric fields.";
		String p6081470 = "an all optics type semiconductor image storage apparatus includes a superlative semiconductor device. the superlattice semiconductor device includes a superlattice layer which is formed by alternately laminating a barrier layer and a quantum well layer. the superlattice layer is interposed between two carrier confinement layers, one of which is formed on a surface of a semiconductor substrate. the superlattice semiconductor device has an effect of modulating a light absorbance in the vicinity of an absorption edge by canceling an internal electric field generated by a piezoelectric effect. this piezoelectric effect is due to a distortion occurring when the superlattice layer is formed. an image is stored so that, light incident into the superlattice semiconductor device at a first stable point is substantially transmitted, while light incident into the device at a second stable point is prevented from being substantially transmitted.";
		
		String claim ="1. a solid-state sensor comprising: * (a) a layer of doped nanocrystals doped with an activator, * (b) said doped nanocrystals having an energy band structure due to quantum confinement, * (c) said activator having atomic energy levels such that excited carriers can transfer to said atomic energy levels and upon recombination will generate photons, * (d) means for detecting the photons generated by the activator.";
		claim = NLPTool.removeNoise(claim);
		System.out.println(claim);
		
		
		List<List<HasWord>> sentences = NLPTool.getSentences(claim);
		for (List<HasWord> sentence : sentences) {
			Tree parse = NLPTool.parseSentToTree(sentence);	
			List<TypedDependency> tdl = NLPTool.getTdFromTree(parse);
			SAOMiner miner = new SAOMiner(tdl);
			PhraseGroup phrases = miner.extractSAO();
			miner.showSAOMap();
			phrases.showAllPhrases();
			
		}	
	}
	
	//property
	private PhraseMiner pMiner;
	private List<TypedDependency> tdl;
	private Map<Integer, SAOItems> saoMap;
	
	//constructor
	public SAOMiner(List<TypedDependency> tdl){
		this.pMiner = new PhraseMiner(tdl);
		this.tdl = this.pMiner.minePhrase();
		this.saoMap = new HashMap<Integer, SAOItems>();
	}
	
	//method
	//===set and get SAO===
	private void putSaoMap(TypedDependency td){
		String reln = td.reln().toString();
		String type = "";
		
		if(Rules.isSubjectRelatedReln(reln)) type = "S";
		else if(Rules.isObjectRelatedReln(reln)) type = "O";
		else return;
		
		SAOItems sao = null;
		TreeGraphNode actionNode = td.gov();
		TreeGraphNode entityNode = td.dep();
		int actionIndex = actionNode.index();
		
		if(this.saoMap.containsKey(actionIndex))
			sao = this.saoMap.get(actionIndex);
		else{
			Verb action = this.pMiner.getOrAddVerbByTGN(actionNode);
			sao = new SAOItems(action);
		}
		
		NounPhrase entity =  this.pMiner.getOrAddNpByTGN(entityNode);
		sao.addEntity(type, entity);
		if(type.equals("S")) sao.setSubjectReln(reln);
		this.saoMap.put(actionIndex, sao);
	}
	
	private SAOItems getSAOByIndex(int index){
		if(this.saoMap.containsKey(index)) 
			return this.saoMap.get(index);
		else
			return null;
	}
	
	//combine object by check verb conj. ex: conj_and(write-2, put-4)
	private void comebineObjects(List<TypedDependency> conjTdl){
		for(TypedDependency td : conjTdl){
			//process gov - main verb
			int govIndex = td.gov().index();
			SAOItems govSAO = this.getSAOByIndex(govIndex);
			if(govSAO == null) continue;
			
			//process dep
			int depIndex = td.dep().index();
			SAOItems depSAO = this.getSAOByIndex(depIndex);
			if(depSAO == null)
				depSAO = new SAOItems(this.pMiner.getOrAddVerbByTGN(td.dep()));
			depSAO.copyFromSAOItems(govSAO); //copy	
		}	
	}
	
	//get PhraseGroup obj
	public PhraseGroup getPhrases(){
		PhraseGroup phrasesObj = new PhraseGroup();
		//List<NounPhrase> npList = this.pMiner.getNpList();
		List<SubjPhrase> spList = new ArrayList<SubjPhrase>();
		List<VerbPhrase> vpList = new ArrayList<VerbPhrase>();
		Set<NounPhrase> opSet = new HashSet<NounPhrase>();
		
		for(int index : this.saoMap.keySet()){
			SAOItems sao = this.saoMap.get(index);
			spList.addAll(sao.getSpList());
			vpList.addAll(sao.getVpList());
			opSet.addAll(sao.getOpSet());
		}
		List<NounPhrase> npList = this.pMiner.getNpList(opSet);
		phrasesObj.addPhrases("np", npList);
		phrasesObj.addPhrases("sp", spList);
		phrasesObj.addPhrases("vp", vpList);
		
		return phrasesObj;
	}
	
	//extract SAO
	public PhraseGroup extractSAO(){
		List<TypedDependency> conjTdl = new ArrayList<TypedDependency>();
		
		//find SAO
		for(int i=0; i<this.tdl.size(); i++){
			TypedDependency td = this.tdl.get(i);
			String reln = td.reln().toString();
			
			if((Rules.isSubjectRelatedReln(reln) || Rules.isObjectRelatedReln(reln))
				&& NLPTool.getTagFromTN(td.gov()).startsWith("VB")
				){
				this.putSaoMap(td);
			}else if(reln.startsWith("conj")
					&& NLPTool.getTagFromTN(td.dep()).startsWith("VB")){
				conjTdl.add(td);
			}
		}
		
		//combine verb(action)
		this.comebineObjects(conjTdl);
		
		return this.getPhrases();
	}
	
	//show SAO detail
	public void showSAOMap(){
		for(int key:this.saoMap.keySet()){
			SAOItems sao = this.saoMap.get(key);
			if(sao.isValid())
				this.saoMap.get(key).showSAO();
		}
		System.out.println();
	}
}
